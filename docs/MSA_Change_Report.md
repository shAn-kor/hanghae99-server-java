# 콘서트 서비스 MSA 변환 보고서
- 도메인 별 서버를 분리하고 각 서버마다 RDBMS를 분리(MSA 구조)해서 사용할 경우 발생하는 문제점과 해결 방안에 대한 보고서이다.

### MSA vs Monolithic Architecture 비교

| 항목 | 모놀리식 아키텍처 (Monolithic) | 마이크로서비스 아키텍처 (MSA) |
|------|-------------------------------|-------------------------------|
| **구성 방식** | 모든 기능이 하나의 애플리케이션으로 통합됨 | 기능(도메인) 별로 서비스가 분리되어 독립적으로 배포 |
| **빌드/배포** | 한 기능만 바꿔도 전체 애플리케이션 재배포 필요 | 개별 서비스 단위로 빌드 및 배포 가능 |
| **확장성** | 전체를 수평 확장해야 함 (낭비 발생 가능) | 서비스별로 독립 확장 가능 (성능/부하 기반 조절) |
| **장애 영향도** | 하나의 문제로 전체 서비스에 영향 가능 | 장애가 해당 마이크로서비스에 국한됨 |
| **데이터베이스** | 단일 DB, 복잡한 쿼리 성능 저하 시 전체 영향 | 서비스별 DB, 도메인별 샤딩/튜닝 가능 |
| **성능 문제 대응** | Oracle → 샤딩/클러스터링으로도 한계 존재 | DB도 서비스 별로 분리해 성능 확보 가능 |
| **개발 속도** | 팀 간 충돌 많고, 빌드/테스트 시간이 길어짐 | 독립된 팀이 빠르게 개발 가능 |
| **기술 스택** | 하나의 기술 스택으로 통일 | 서비스별로 언어/프레임워크 자유롭게 선택 가능 |
| **테스트** | 통합 테스트 환경 필수 | 개별 서비스 단위 테스트 용이 |
| **운영 복잡도** | 구조 단순, 운영은 쉬움 | 분산 시스템 운영 복잡도 존재 |

---
### 요약

- 모놀리식: 초기 개발은 빠르지만, 커지면 배포 리스크 및 장애 범위가 커진다.
- MSA: 초기 복잡하지만, 도메인 단위로 성능 튜닝 및 장애 격리가 용이하다.
- 특히 DB 성능 한계 극복에는 MSA 구조가 효과적이다.

## 1. 도메인 별 서버 분리

- 콘서트
  - (공연, 공연 일정, 공연장) 연관된 세 도메인 묶어 콘서트로 분리한다.

- 주문
  - (주문, 주문 상품(좌석)) 묶어 주문으로 분리한다.
- 결제
- 대기열

## 2. 도메인 별 서버 분리 시 문제점
- 조인이 불가능해진다.
- 데이터베이스의 물리적인 트랜잭션 사용이 불가능해진다.

## 3. 트랜잭션 처리 한계점 해결방안
- SAGA 패턴을 사용해 분산 트랜잭션 환경에서 데이터 일관성을 유지한다.

#### SAGA 패턴
- 분산 트랜잭션 환경에서 메시지 또는 이벤트를 주고 받으며 서비스 간의 데이터 일관성을 지키기 위한 패턴이다.
- SAGA 패턴 구현 방식에는 오케스트레이션, 코레오그래피가 있다.

#### 오케스트레이션 VS 코레오그래피
| 항목                     | 오케스트레이션 방식                                | 코레오그라피 방식                                |
|------------------------|--------------------------------------------------|--------------------------------------------------|
| **정의**                | 중앙 컨트롤러(Orchestrator)가 전체 흐름을 제어함        | 각 서비스가 이벤트를 수신하고 다음 작업을 수행함     |
| **제어 주체**           | 중앙의 오케스트레이터 서비스                          | 각 개별 서비스                                    |
| **통신 방식**           | 주로 동기 호출 (REST 등) + 보상 트랜잭션                | 주로 비동기 이벤트 기반 (Kafka, RabbitMQ 등)     |
| **구현 난이도**         | 중앙 집중식 설계로 복잡도가 낮고 가시성이 높음           | 분산 구조로 복잡도가 높지만 유연함                 |
| **확장성**              | 중앙 오케스트레이터에 로직이 집중되어 유연성 낮음         | 서비스 간 결합도가 낮아 확장성 우수                 |
| **장애 전파**           | 오케스트레이터 장애 시 전체 트랜잭션 흐름 중단 위험       | 특정 서비스 장애가 전체에 영향을 미치지 않음         |
| **가시성**              | 전체 흐름을 한 곳에서 관리하므로 트랜잭션 추적이 쉬움     | 이벤트 기반이라 로그와 추적 시스템이 필요함           |
| **실패 시 처리**        | 보상 트랜잭션 호출을 오케스트레이터가 책임짐             | 각 서비스가 스스로 보상 트랜잭션을 처리함            |
| **적합한 경우**         | 트랜잭션 흐름이 명확하고 관리가 쉬워야 하는 경우          | 동적으로 변화하는 비즈니스 로직에 유연하게 대응할 경우 |

### 4. SAGA 패턴 적용 예시

#### 1. 예약-결제 SAGA 흐름 예시
1. 예약 서비스에서 `예약 상태 확인`
2. 결제 서비스에 `결제 요청 이벤트` 전달
3. 결제가 성공하면 → 예약 상태를 `CONFIRMED`로 업데이트
4. 결제가 실패하면 → 예약을 `CANCELED`로 롤백

#### 2. 보상 트랜잭션 설계

- 실패 발생 시 역작업을 수행할 수 있도록 **보상 메서드** 명확히 정의
- 예: 결제 실패 시 포인트 반환, 좌석 예약 취소

## 6. 기대 효과

| 항목 | 효과 |
|------|------|
| 개발/배포 효율 | 서비스 단위로 CI/CD 가능, 변경 영향도 최소화 |
| 장애 격리 | 특정 도메인의 장애가 전체 서비스로 확산되지 않음 |
| 성능 최적화 | 서비스별로 트래픽 특성에 따라 서버 확장 가능 |
| 기술 유연성 | 각 서비스 별로 최적의 기술 스택 사용 가능 |

---

## 7. 향후 고려사항

- 이벤트 저장소의 중복 처리 및 순서 보장 설계
- 각 서비스 간 데이터 중복 허용 범위 명확화
- 분산 트레이싱, 모니터링 도구 도입 (e.g. Zipkin, Prometheus, Grafana)

---

## 결론

- 도메인 분리는 확장성과 유지보수성을 획기적으로 높여주지만, 분산 트랜잭션의 복잡성이 높아지는 문제가 있다.
- SAGA 패턴과 이벤트 기반 아키텍처를 통해 이러한 문제를 해결하며, MSA 환경에서도 정합성과 유연성을 갖춘 서비스 운영이 가능하도록 설계한다.