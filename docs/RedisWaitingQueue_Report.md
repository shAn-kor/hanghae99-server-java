# 콘서트 예약 시스템 - Redis 기반 대기열 기능 설계 및 개선 보고서

## 🧭 목적

높은 트래픽이 예상되는 콘서트 예약 서비스에서 사용자의 **동시 진입**에 대응하고,  
공정한 대기 순서를 보장하며, **DB 부하 없이 안정적으로 좌석 예약을 유도**하기 위해  
Redis를 기반으로 한 **대기열 시스템**을 설계하고 구현한다.

---

## ✅ 시스템 요구사항

- 수천 명 이상이 동시에 접속하여 예약을 시도할 수 있음
- 사용자마다 대기 순서를 부여하고, 최대 50명만 동시에 예약 가능 (활성 대기열)
- 대기열에 진입한 사용자에게는 토큰을 발급하고 유효 시간(TTL)을 적용
- 예약 완료, 이탈 등의 이유로 자리가 생기면 대기열에서 순차적으로 활성 대기열을 채움

---

## 🗂 구조 설계

### 1. Redis 자료구조 활용

| 역할          | Key 예시                        | Redis 자료구조   | 설명 |
|---------------|----------------------------------|------------------|------|
| 대기열         | `queue:concert:{concertId}`      | Sorted Set (ZSet) | 사용자 UUID를 score와 함께 저장 (score = 진입순서) |
| 대기 정보 TTL | `queue:concert:{id}:info:{uuid}` | String + TTL     | 사용자의 진입 시간 기록 (TTL 10분) |
| 활성 대기열   | `active:concert:{concertId}`     | Set              | 최대 50명까지만 허용, 실제 예약 가능 상태 |

---

### 2. 핵심 로직 요약

#### 대기열 진입 (Token 발급)

```java
ZADD queue:concert:1 <score> <userId>
SADD queue:concert:1:set <userId>
SET queue:concert:1:info:<userId> <timestamp> EX 600
```

- 이미 대기열에 존재하면 재삽입 방지
- 활성 대기열에 여유 있으면 바로 SADD

---

#### 활성 대기열 자동 채움

```java
if (activeSet.size() < 50):
    ZRANGE queue:concert:1 0 N → SADD active
    ZREM queue
```

- 만약 예약 취소, 유효시간 만료 등으로 빈자리가 생기면
- 대기열 맨 앞 유저를 `active set`으로 이동

---

#### 예약 완료 후 처리

```java
SREM active:concert:1 <userId>
DEL queue:concert:1:info:<userId>
ZREM queue:concert:1 <userId>
```

- 유저의 대기열 정보 제거 및 활성 목록에서 제거
- 다음 유저 자동 승급 처리

---

## 🎯 개선된 쿠폰 발급/예약 흐름

1. 클라이언트는 예약 요청 전 대기열에 진입 (`/token`)
2. 50명 이내면 즉시 예약 가능. 그 외에는 대기상태로 진입
3. Redis 기반 활성 대기열 승급 로직에 따라 자동으로 사용자에게 예약 권한 부여
4. 유저는 `/reserve` 시 유효성 검증 (`isValid`) 후 좌석 예약
5. 예약 완료 → 다음 사용자로 활성 대기열 자동 보충

---

## 🔒 동시성 및 장애 대응 설계

- Redisson 기반 `@DistributedLock` 적용: 동일 사용자에 대한 중복 처리 방지
- TTL 기반 자동 만료로 유령 사용자 방지
- 분산 환경에서도 Redis 기반 자료구조로 일관된 처리 보장
- 트랜잭션 커밋 이후 `fillActiveQueue` 실행으로 락 해제 후 안전하게 다음 대기열 처리

---

## 📊 기대 효과

- 트래픽 폭주 상황에서도 안정적으로 사용자 흐름 제어 가능
- DB에는 예약 확정 요청만 전달되므로 부하 최소화
- 사용자 입장에서 예측 가능하고 공정한 대기 방식 제공

---

## 🔚 마무리 및 회고

Redis의 ZSet과 Set을 활용하여 트래픽이 집중되는 상황에서도 정합성을 보장하면서  
부드럽고 효율적인 대기열 흐름을 구현할 수 있었다. 특히 TTL 기반 제어, 자동 승급 로직 등은  
실제 서비스 환경에서도 충분히 확장 가능한 방식이라 판단된다.

> 추후 과제로 Kafka 기반 비동기 처리 + WebSocket 응답 전파 기능도 고려하면 좋을 것이다.
